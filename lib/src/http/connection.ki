
use io;
use net;
use utils;

class Connection {
	netcon: net:Connection;
	fd: i32;
	uploads: ?Array[String] = null;
	read_buf: utils:ByteBuffer = utils:ByteBuffer.init(500);
	out_buf: utils:ByteBuffer = utils:ByteBuffer.init(500);
	out_pos: uxx = 0;

	// Parsing
	phase: uxx = 0;
	parse_pos: uxx = 0;
	line: utils:ByteBuffer = utils:ByteBuffer.init(200);
	headers_parsed: bool = false;
	headers: Map[String] = Map[String].init();
	request_method: String = "GET";

	func parse_headers() void !sent_error {
		if this.headers_parsed {
			return;
		}

		let mut phase = this.phase;
		let mut pos = this.parse_pos;
		let read_buf = this.read_buf;
		let line = this.line;
		let length = read_buf.length;
		let data = read_buf.data;
		let mut prev_ch = '\0';
		if line.length > 0 {
			prev_ch = ptrv (line.data + line.length - 1) as u8;
		}
		while pos < length {
			let ch = ptrv (data + pos) as u8;
			pos++;

			if prev_ch == '\r' && ch == '\n' {

				line.length--; // Remove \r

				if line.length == 0 {
					this.headers_parsed = true;
					break;
				}

				if phase == 1 {
					// Header
					let headers = this.headers;
					let split_index = line.index_of_byte(':') !! {
						this.respond(Response.error(415)); // Invalid request
						throw sent_error;
					};
					// Key
					let key = line.sub_str(0, split_index);

					// Value
					let value_start_index = split_index + 1;
					let value_index = line.index_where_byte_is_not(' ', value_start_index) !? value_start_index;
					let value = line.sub_str(value_index, line.length - value_index);

					//println(key + " -> " + value);
					headers.set(key, value);

				} else if phase == 0 {
					// HTTP line
					//println(line.to_str());
					//this.respond(Response.error(415)); // Unsupported protocol
					phase = 1;
				}

				line.clear();
				prev_ch = '\n';
				continue;
			}
			line.append_byte(ch);
			prev_ch = ch;
		}

		this.parse_pos = pos;
	}

	func respond(resp: Response) void {
		resp.compile(this.out_buf);
		this.send_response_bytes();
	}

	func has_data_to_send() bool {
		return this.out_pos < this.out_buf.length;
	}

	// Returns 'true' if all bytes were sent
	func send_response_bytes() bool {
		let out = this.out_buf;
		let pos = this.out_pos;
		let mut bytes = out.length - pos;
		if bytes > 0 {
			let wbytes = io:write_from_ptr(this.fd, out.data + pos, bytes) !? 0;
			this.out_pos += wbytes;
		}
		return this.out_pos == out.length;
	}
}


