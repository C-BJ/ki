
header "ki_os" as kos;

use ki:os;
use ki:net;
use ki:io;

class ServerData async {
	connections: AsyncArray[?Connection];
	socket: net:SocketTCP;
	thread_nr: uxx = 0;
}

class Server {
	host: String;
	handler: fn(Request)(Response);
	max_connections: uxx;
	data: ServerData;
	port: u16;


	static func init(host: +String, port: u16, handler: fn(Request)(Response)) .Server !socket_init_error {

		let max_connections : uxx = 10000;
		let socket = net:Socket.init_tcp(host, port) !! throw socket_init_error;;

		return Server{
			host: host,
			port: port,
			handler: handler,
			max_connections: max_connections,
			data: ServerData {
				socket: socket,
				connections: AsyncArray[?Connection].init(max_connections),
			}
		};
	}

	func .start(mut worker_count: i32 = 8) void {

		// SIGINT
        os:signal(os:SIG.hup, interrupt);
        // SIGPIPE
        os:signal_ignore(os:SIG.pipe);

		if worker_count < 1 {
			worker_count = 1;
		}
		if worker_count > 128 {
			worker_count = 128;
		}

		println("[+] Running http server on port " + this.port.str());
		println("[+] Worker count: " + worker_count.str());

		worker_count--;
		while worker_count > 0 {
			//break;
			worker_count--;
			let thread = os:Thread[ServerData].start(Server.worker, this.data);
		}
		Server.worker(this.data);
		os:sleep_ms(200);
	}

	private static func worker(data: ServerData) void {
		let cons = data.connections;
		let nr = atomicop data.thread_nr ADD 1;

		let nr_str = nr.str();
		println("Thread: " + nr.str());

		let sock = data.socket;
		let sock_fd = sock.fd;

		let poll = io:Poll.init();
		let sock_lsn = poll.listener(sock_fd);
		sock_lsn.read(true);

		while true {
			let result = poll.wait();
			let result_count = result.count;
			let mut i : u32 = 0;

			while i < result_count {
				let event = result.get(i) ?! break;;
				i++;

				let lsn = event.listener;
				let fd = lsn.fd;

				//println("üëã Event thread: " + nr.str() + " | FD: " + fd.str());

				if fd == sock_fd {
					// New connection
					let netcon = sock.accept() !! {
						continue;
					};

					println("ü§ù Accept: " + nr.str());

					let index = cons.push(null);

					//println("Netcon fd: " + netcon.fd.str());
					//println("Http cons index: " + index.str());
					let lsn = poll.listener(netcon.fd, index -> u32);
					lsn.read(true);
					lsn.stopped_reading(true);

					let http_con = Connection {
						netcon: netcon,
						fd: netcon.fd,
					};
					http_con._RC+=1;

					cons.set(index, http_con)!;

					continue;
				}

				// Get connection
				let http_con = cons.get(lsn.key) !! {
					println("‚ùì Missing http connection : " + nr.str());
					io:close(fd);
					poll.remove(lsn);
					continue;
				};
				rep http_con = http_con ?! {
					println("‚ùî Http connection is 'null' : " + nr.str());
					io:close(fd);
					poll.remove(lsn);
					continue;
				};
				http_con._RC+=1;
				if http_con.fd != fd {
					println("‚ùó fd changed : " + nr.str() + " | " + http_con.fd.str() + " -> " + fd.str() + " | key: " + lsn.key.str());
					io:close(fd);
					poll.remove(lsn);
					continue;
				}

				// Existing connection
				if event.is_error() {
					println("error: " + nr.str());
					io:close(fd);
					poll.remove(lsn);
					continue;
				}
				if event.is_closed() {
					println("closed: " + nr.str());
					io:close(fd);
					poll.remove(lsn);
					continue;
				}
				if event.is_stopped_reading() {
					println("stopped: " + nr.str() + " | fd: " + fd.str());
					io:close(fd);
					poll.remove(lsn);
					continue;
				}
				if event.is_writable() {
					println("send more: " + nr.str());
					continue;
				}
				if event.is_readable() {
					//println("üñäÔ∏è Respond: " + nr.str());
					Server.respond(http_con);
					//println("‚úîÔ∏è Sent");
					//poll.remove(lsn);
					continue;
				}
			}
		}

		println("Socket: " + sock_fd.str());
	}

	static func respond(http_con: Connection) void {

		let buf_size : i32 = 65535;
		let sbuf : ptr = stack_alloc(buf_size);
		while true {
			let rcvd = kos.ki_os__fd_read(http_con.fd, sbuf, buf_size);
			//println("Recv: " + rcvd.str() + " | fd: " + http_con.fd.str());
			if (rcvd == -2){
				// EAGAIN
				break;
			} else if (rcvd < 0){
				break;
			} else if (rcvd == 0){
				break;
			}
			if(rcvd < buf_size) {
				break;
			}
		}

		let resp = "HTTP/1.1 200 OK\r\nContent-Length: 13\r\nConnection: keep-alive\r\nContent-Type: text/html\r\n\r\nHello, World!";

		io:write(http_con.fd, resp);
		//io:close(http_con.fd);
		//println("‚ùå Close");
	}
}

global interrupted : bool;
func interrupt(sig: i32) void {
    if(interrupted){
        os:exit(1);
    }
    interrupted = true;
    println("Interrupt - Stopping http servers...");
    os:exit(1);
}
