
header "ki_os" as kos;

use ki:os;

class Server async {
	host: String;
	handler: fn(Request)(Response);
	connections: AsyncArray[Connection];
	max_connections: uxx;
	//
	port: u32;


	static func init(>host: String, port: u32, handler: fn(Request)(Response)) Server {

		let max_connections : uxx = 10000;

		return Server{
			host: host,
			port: port,
			handler: handler,
			connections: AsyncArray[Connection].init(max_connections),
			max_connections: max_connections,
		};
	}

	func >$start(mut worker_count: i32 = 8) void {

		// SIGINT
        os:signal(os:SIG.hup, interrupt);
        // SIGPIPE
        os:signal_ignore(os:SIG.pipe);

		if worker_count < 1 {
			worker_count = 1;
		}
		if worker_count > 128 {
			worker_count = 128;
		}

		println("[+] Running http server on port " + this.port.str());
		println("[+] Worker count: " + worker_count.str());

		let mutex = os:Mutex[Server].init(this);

		worker_count--;
		while worker_count > 0 {
			worker_count--;
			let thread = os:Thread[os:Mutex[Server]].start(Server.worker, mutex);
		}
		Server.worker(mutex);
		os:sleep_ms(200);
	}

	private static func worker(mutex: os:Mutex[Server]) void {
		let server = mutex.lock();
		let cons = server.connections;
		mutex.unlock(server);

		println("hello");
	}

}

global interrupted : bool;
func interrupt(sig: i32) void {
    if(interrupted){
        os:exit(1);
    }
    interrupted = true;
    println("Interrupt - Stopping http servers...");
    os:exit(1);
}
