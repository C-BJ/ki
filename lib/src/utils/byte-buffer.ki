
use mem;

class ByteBuffer {
	readonly data: ptr;
	readonly size: uxx;
	readonly length: uxx = 0;

	static func init(mut start_size: uxx) .ByteBuffer {
		if start_size < 10 {
			start_size = 10;
		}
		return ByteBuffer {
			data: mem:alloc(start_size),
			size: start_size,
		};
	}

	// Appending

	func append(data: ptr, length: uxx) void {
		if(length == 0) {
			return;
		}
		let bytes : uxx = this.length;
		let new_bytes : uxx = bytes + length;
		if(new_bytes > this.size){
			this.increase_size(new_bytes);
		}
		let to : ptr = this.data + bytes;
		mem:copy(data, to, length);
		this.length = new_bytes;
	}

	func append_byte(byte: u8) void {
		let bytes : uxx = this.length;
		let new_bytes : uxx = bytes + 1;
		if(new_bytes > this.size){
			this.increase_size(new_bytes);
		}
		let to : ptr = this.data + bytes;
		ptrv to as u8 = byte;
		this.length = new_bytes;
	}

	func append_str(str: String) void {
		this.append(str.data(), str.bytes());
	}

	// Compare

	func eq_str(str: String) bool {
		let str_len = str.bytes();
		let len = this.length;
		if str_len != len {
			return false;
		}
		return mem:equal(this.data, str.data(), len);
	}

	// Converts

	public func to_str() String {
		if(this.length == 0){
			return "";
		}
		let str = String.make_empty(this.length -> u32);
		mem:copy(this.data, str.data(), this.length);
		return str;
	}

	// 

	public func increase_size(minimum_size: uxx) void {
		let size : uxx = this.size;
		let mut new_size : uxx = size;
		while new_size < minimum_size {
			new_size *= 2;
		}
		if(new_size != size){
			let adr : ptr = mem:alloc(new_size);
			mem:copy(this.data, adr, this.length);
			mem:free(this.data);
			this.size = new_size;
			this.data = adr;
		}
	}

}
