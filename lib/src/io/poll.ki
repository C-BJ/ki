
header "ki_os" as kos;
header "sys" as sys;

use mem;
use utils;

class Poll {
	private fd: i32;
	private resultc: uxx = 0;
	private results: sys.cstruct_epoll_event[unsafe];
	//
	private pool: utils:Pool[PollListener];
	private listeners: Array[PollListener] = Array[PollListener].init();
	readonly max_connections: uxx;

	public static func init(max_connections: uxx) Poll {

		#if OS == linux
		let fd = sys.epoll_create(1);
		let results = mem:calloc(sizeof_class(sys.cstruct_epoll_event) * 20) @as sys.cstruct_epoll_event[unsafe];
		#end

		let x = Poll {
			fd: fd,
			results: results,
			pool: utils:Pool[PollListener].init(max_connections),
			max_connections: max_connections,
		};
		return x;
	}

	public func listener(fd: i32, key: uxx = 0) PollListener {

		let pool = this.pool;
		let listeners = this.listeners;

		let lsn = pool.pop() !? @vs : PollListener {
			let new = PollListener {
				os_poll: this.os_poll,
				fd: fd,
				key: key,
			};
			//listeners.push(new);
			return new;
		};

		lsn.fd = fd;
		lsn.key = key;

		let ev = stack_object(sys.cstruct_epoll_event);
    	ev.events = 0;
    	ev.data.ptr = lsn @as ptr;
    	let res = sys.epoll_ctl(this.fd, EPOLL_CTL_ADD, fd, ev);

		return lsn;
	}

	public func remove(listener: PollListener) void {

		let ev = stack_object(sys.cstruct_epoll_event);
    	ev.events = 0;
    	let res = sys.epoll_ctl(this.fd, EPOLL_CTL_ADD, listener.fd, ev);

		this.pool.add(listener)!;
	}

	public func wait(timeout: i32 = -1) PollResult {

    	let event_count = sys.epoll_wait(this.fd, this.results, 20, timeout);

    	ki_poll_result *result = p->result;
    	result->count = event_count;

    	for (int i = 0; i < event_count; i++) {
    	    struct epoll_event *e = p->events + i;
    	    ki_poll_event *ke = result->events + i;
    	    ke->listener = e->data.ptr;
    	    unsigned short state = 0;
    	    int states = e->events;
    	    if (states & EPOLLIN) {
    	        state = state | 0x1;
    	    }
    	    if (states & EPOLLOUT) {
    	        state = state | 0x2;
    	    }
    	    if (states & EPOLLERR) {
    	        state = state | 0x4;
    	    }
    	    if (states & EPOLLHUP) {
    	        state = state | 0x8;
    	    }
    	    if (states & EPOLLRDHUP) {
    	        state = state | 0x10;
    	    }
    	    ke->state = state;
    	}

    	return result;

		return kos.ki_os__poll_wait(this.os_poll, timeout);
	}

	public func 

	public func __before_free() void {

		while true {
			let item = this.listeners.pop() !! break;;
			item.__free();
		}
		//each this.listeners as li {
		//	li.__free();
		//}

		//kos.ki_os__poll_free(this.os_poll);
	}
}

struct PollListener {
	private os_poll: ptr;
    readonly key: uxx = 0;
	readonly fd : i32 = -1;
    private state: u32 = 0;

	public func read(v: bool) void {
		if(v) {
			this.state = this.state | 0x1;
		} else if (this.state & 0x1) > 0 {
			this.state = this.state ^ 0x1;
		}
		kos.ki_os__poll_update_fd(this.os_poll, this);
	}
	public func write(v: bool) void {
		if(v) {
			this.state = this.state | 0x2;
		} else if (this.state & 0x2) > 0 {
			this.state = this.state ^ 0x2;
		}
		kos.ki_os__poll_update_fd(this.os_poll, this);
	}
	public func stopped_reading(v: bool) void {
		if(v) {
			this.state = this.state | 0x10;
		} else if (this.state & 0x10) > 0 {
			this.state = this.state ^ 0x10;
		}
		kos.ki_os__poll_update_fd(this.os_poll, this);
	}
}

struct PollResult {
	private events: ptr;
	readonly count: u32;

	public func get(index: u32) ?PollEvent {
		if(index >= this.count) {
			return null;
		}
		let adr : ptr = this.events + (index * @sizeof_class(PollEvent));
		return adr @as PollEvent;
	}
}

struct PollEvent {
    readonly listener: PollListener;
    readonly state: u32;
	// States
    // 0x1  : in
    // 0x2  : out
    // 0x4  : err
    // 0x8  : closed
    // 0x10 : stopped_reading

	public func is_readable() bool %inline {
		return (this.state & 0x1) > 0;
	}
	public func is_writable() bool %inline {
		return (this.state & 0x2) > 0;
	}

	public func is_error() bool %inline {
		return (this.state & 0x4) > 0;
	}
	public func is_closed() bool %inline {
		return (this.state & 0x8) > 0;
	}
	public func is_stopped_reading() bool %inline {
		return (this.state & 0x10) > 0;
	}

	public func wants_to_close() bool %inline {
		return (this.state & 0x4) > 0 || (this.state & 0x8) > 0 || (this.state & 0x10) > 0;
	}
}


