
header "ki_os" as kos;

use mem;
use utils;

class Poll {
	readonly os_poll: ptr;
	private pool: utils:Pool[PollListener];
	private listeners: Array[PollListener] = Array[PollListener].init();
	readonly max_connections: uxx;

	public static func init(max_connections: uxx) Poll {
		let p = kos.ki_os__poll_init();
		let x = Poll {
			os_poll: p,
			pool: utils:Pool[PollListener].init(max_connections),
			max_connections: max_connections,
		};
		return x;
	}

	public func listener(fd: i32, key: uxx = 0) PollListener {

		let pool = this.pool;
		let listeners = this.listeners;

		let lsn = pool.pop() !? @vs : PollListener {
			let new = PollListener {
				os_poll: this.os_poll,
				fd: fd,
				key: key,
			};
			//listeners.push(new);
			return new;
		};

		lsn.fd = fd;
		lsn.key = key;

		kos.ki_os__poll_new_fd(this.os_poll, lsn);

		return lsn;
	}

	public func remove(listener: PollListener) void {
		kos.ki_os__poll_remove_fd(this.os_poll, listener);
		this.pool.add(listener)!;
	}

	public func wait(timeout: i32 = -1) PollResult {
		return kos.ki_os__poll_wait(this.os_poll, timeout);
	}

	public func __before_free() void {

		while true {
			let item = this.listeners.pop() !! break;;
			item.__free();
		}
		//each this.listeners as li {
		//	li.__free();
		//}

		kos.ki_os__poll_free(this.os_poll);
	}
}

struct PollListener {
	private os_poll: ptr;
    readonly key: uxx = 0;
	readonly fd : i32 = -1;
    private state: u32 = 0;

	public func read(v: bool) void {
		if(v) {
			this.state = this.state | 0x1;
		} else if (this.state & 0x1) > 0 {
			this.state = this.state ^ 0x1;
		}
		kos.ki_os__poll_update_fd(this.os_poll, this);
	}
	public func write(v: bool) void {
		if(v) {
			this.state = this.state | 0x2;
		} else if (this.state & 0x2) > 0 {
			this.state = this.state ^ 0x2;
		}
		kos.ki_os__poll_update_fd(this.os_poll, this);
	}
	public func stopped_reading(v: bool) void {
		if(v) {
			this.state = this.state | 0x10;
		} else if (this.state & 0x10) > 0 {
			this.state = this.state ^ 0x10;
		}
		kos.ki_os__poll_update_fd(this.os_poll, this);
	}
}

struct PollResult {
	private events: ptr;
	readonly count: u32;

	public func get(index: u32) ?PollEvent {
		if(index >= this.count) {
			return null;
		}
		let adr : ptr = this.events + (index * sizeof_class(PollEvent));
		return adr @as PollEvent;
	}
}

struct PollEvent {
    readonly listener: PollListener;
    readonly state: u32;
	// States
    // 0x1  : in
    // 0x2  : out
    // 0x4  : err
    // 0x8  : closed
    // 0x10 : stopped_reading

	public func is_readable() bool %inline {
		return (this.state & 0x1) > 0;
	}
	public func is_writable() bool %inline {
		return (this.state & 0x2) > 0;
	}

	public func is_error() bool %inline {
		return (this.state & 0x4) > 0;
	}
	public func is_closed() bool %inline {
		return (this.state & 0x8) > 0;
	}
	public func is_stopped_reading() bool %inline {
		return (this.state & 0x10) > 0;
	}

	public func wants_to_close() bool %inline {
		return (this.state & 0x4) > 0 || (this.state & 0x8) > 0 || (this.state & 0x10) > 0;
	}
}


