
header "ki_os" as kos;
header "sys" as sys;

use mem;
use utils;

class Poll {
	private fd: i32;
	private resultc: uxx = 0;
	private results: ptr;
	private results_int: ptr;
	//
	private pool: utils:Pool[PollListener];
	private listeners: Array[PollListener] = Array[PollListener].init();
	readonly max_connections: uxx;

	public static func init(max_connections: uxx) Poll {

		#if OS == linux
		let fd = sys.epoll_create(1);
		let results = mem:calloc(@sizeof_class(sys.cstruct_epoll_event) * 20);
		#end

		let results_int = mem:calloc(@sizeof_class(PollEvent) * 20);

		return Poll {
			fd: fd,
			results: results,
			results_int: results_int,
			pool: utils:Pool[PollListener].init(max_connections),
			max_connections: max_connections,
		};
	}

	public func listener(fd: i32, key: uxx = 0) PollListener {

		let pool = this.pool;
		let listeners = this.listeners;

		let lsn = pool.pop() !? @vs : PollListener {
			let new = PollListener {
				poll_fd: this.fd,
				fd: fd,
				key: key,
			};
			//listeners.push(new);
			return new;
		};

		lsn.fd = fd;
		lsn.key = key;

		let ev = @stack_object(sys.cstruct_epoll_event);
    	ev.events = 0;
    	ev.data = lsn @as ptr;
    	let res = sys.epoll_ctl(this.fd, sys.OS.EPOLL_CTL_ADD, fd, ev);
		if res != 0 {
			//println("> Failed to add epoll listener");
		}

		return lsn;
	}

	public func remove(listener: PollListener) void {

		let ev = @stack_object(sys.cstruct_epoll_event);
    	ev.events = 0;
    	let res = sys.epoll_ctl(this.fd, sys.OS.EPOLL_CTL_DEL, listener.fd, ev);

		this.pool.add(listener)!;
	}

	public func wait(timeout: i32 = -1) uxx {

		let results = this.results;
    	let event_count = sys.epoll_wait(this.fd, results, 10, timeout);
		if event_count < 0 {
			return 0;
		}
		rep event_count = event_count @as uxx;

		this.resultc = event_count;

		let results_int = this.results_int;

		let i : uxx = 0;
    	while i < event_count {
    	    let e = (results + (i * @sizeof_class(sys.cstruct_epoll_event))) @as sys.cstruct_epoll_event;
    	    let ei = (results_int + (i * @sizeof_class(PollEvent))) @as PollEvent;
			i++;
    	    ei.events = e.events;
    	    ei.listener = e.data @as PollListener;
    	}

    	return event_count;
	}

	public func get_event(index: uxx) &PollEvent !invalid_index {
		if(index >= this.resultc) {
			throw invalid_index;
		}
		let results_int = this.results_int;
    	return (results_int + (index * @sizeof_class(PollEvent))) @as PollEvent;
	}

	public func __before_free() void {

		while true {
			let item = this.listeners.pop() !! break;;
			item.__free();
		}
		//each this.listeners as li {
		//	li.__free();
		//}

		//kos.ki_os__poll_free(this.os_poll);
	}
}

struct PollListener {
	private poll_fd: i32;
    readonly key: uxx = 0;
	readonly fd : i32 = -1;
    private detect_events: u32 = 0;

	public func read(v: bool) void {
		if(v) {
			this.detect_events = this.detect_events | sys.OS.EPOLLIN;
		} else if (this.detect_events & sys.OS.EPOLLIN) > 0 {
			this.detect_events = this.detect_events ^ sys.OS.EPOLLIN;
		}
		this.update_epoll();
	}
	public func write(v: bool) void {
		if(v) {
			this.detect_events = this.detect_events | sys.OS.EPOLLOUT;
		} else if (this.detect_events & sys.OS.EPOLLOUT) > 0 {
			this.detect_events = this.detect_events ^ sys.OS.EPOLLOUT;
		}
		this.update_epoll();
	}
	public func stopped_reading(v: bool) void {
		if(v) {
			this.detect_events = this.detect_events | sys.OS.EPOLLRDHUP;
		} else if (this.detect_events & sys.OS.EPOLLRDHUP) > 0 {
			this.detect_events = this.detect_events ^ sys.OS.EPOLLRDHUP;
		}
		this.update_epoll();
	}
	private func update_epoll() void {
		let ev = @stack_object(sys.cstruct_epoll_event);
    	ev.events = this.detect_events;
    	ev.data = this @as ptr;
    	let res = sys.epoll_ctl(this.poll_fd, sys.OS.EPOLL_CTL_MOD, this.fd, ev);
		if res != 0 {
			//println("> Failed to update epoll events");
		}
	}
}

struct PollEvent {
    readonly listener: PollListener;
    readonly events: u32;

	public func is_readable() bool %inline {
		return (this.events & sys.OS.EPOLLIN) > 0;
	}
	public func is_writable() bool %inline {
		return (this.events & sys.OS.EPOLLOUT) > 0;
	}
	public func is_stopped_reading() bool %inline {
		return (this.events & sys.OS.EPOLLRDHUP) > 0;
	}

	public func wants_to_close() bool %inline {
		return (this.events & sys.OS.EPOLLRDHUP) > 0;
	}
}


