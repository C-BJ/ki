
use mem;

class Array[T] {
	readonly size: uxx;
	readonly length: uxx = 0;
	readonly data: ptr;

	static func init(start_size: uxx = 2) .CLASS {
		if start_size < 2 {
			start_size = 2;
		}
		return CLASS {
			size: start_size,
			data: mem:alloc(start_size * sizeof(T)),
		};
	}

	func push(item: >T) uxx {
		let size = this.size;
		let length = this.length;
		let data = this.data;

		if length == size {
			// Increase mem
			let new_size = size * 2;
			let new_data = mem:alloc(new_size * sizeof(T));
			mem:copy(data, new_data, size * sizeof(T));
			data = new_data;
			this.data = new_data;
			this.size = new_size;
		}

		@ptrv(data, T, length) = item;
		this.length = length + 1;
		@move item;

		return length;
	}

	public func prepend(item: >T) void {

		let size = this.size;
		let length = this.length;
		let data = this.data;

		if length == size {
			// Increase mem
			let new_size = size * 2;
			let new_data = mem:alloc(new_size * sizeof(T));
			mem:copy(data, new_data, size * sizeof(T));
			data = new_data;
			this.data = new_data;
			this.size = new_size;
		}

		let to_pos = length;
		while to_pos > 0 {
			@ptrv(data, T, to_pos) = @ptrv(data, T, to_pos - 1);
			to_pos--;
		}

		@ptrv(data, T, 0) = item;
		this.length = length + 1;
		@move item;
	}

	func get(index: uxx) T !not_found {
		if index >= this.length {
			throw not_found;
		}

		let value = @ptrv(this.data, >T, index);
		@ref value;

		return value;
	}

	func set(index: uxx, value: >T) void !out_of_range {
		if index >= this.length {
			throw out_of_range;
		}
		let data = this.data;
		let current = @ptrv(data, >T, index);

		@ptrv(data, T, index) = value;
		@move value;
	}

	func remove(index: uxx) void {
		println(index.str());
		if index == this.length - 1 {
			this.length--;
		}
		println("remove: " + (this.length).str());
	}
	func pop() void {
		if this.length > 0 {
			this.remove(this.length - 1);
		}
	}

	func index_of(item: T) uxx !not_found {
		let index : uxx = 0;
		let adr = this.data;
		let len = this.length;
		while(index < len){
			let x = @ptrv(adr, T, index);
			if x == item {
				return index;
			}
			index++;
		}
		throw not_found;
	}

	// Internals
	func __each_init() uxx {
		return 0;
	}

	//#if IS_STRICT_TYPE T
	//func __each(key_ref: uxx[1]) imut T !end {
	//	let key = key_ref[0];
	//	if key >= this.length {
	//		throw end;
	//	}
	//	key_ref[0] = key + 1;

	//	let result = @ptrv(this.data, >imut T, key);
	//	@ref result;

	//	return result;
	//}

	//#else

	func __each(key_ref: uxx[1]) T !end {
		let key = key_ref[0];
		if key >= this.length {
			throw end;
		}
		key_ref[0] = key + 1;
		return this.get(key) !! throw end;;
	}
	//#end

	func __before_free() void {
		// Deref items
		let index = 0#uxx;
		let length = this.length;
		let data = this.data;
		while index < length {
			let value = @ptrv(data, >T, index);
			index++;
		}

		//
		mem:free(this.data);
	}
}
