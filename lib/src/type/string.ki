
// const:   {string_length:uxx}-1-{...string bytes...}
// dynamic: {string_length:uxx}-0-{pad 3}-{ref_count:u32}-{...string bytes...}

use mem;
use os;

class String type:ptr async {

	/////////////////////
	// Core
	/////////////////////

	func is_const() bool %inline {
		return (ptrv (this -> ptr + sizeof(uxx)) as u8) == 1#u8;
	}

	func bytes() uxx %inline {
		return ptrv (this -> ptr) as uxx;
	}

	func rc() u32 %inline {
		if(this.is_const()) { return 666; } // Let the person who has insight calculate the number of the beast, for it is the number of a man. That number is 666.
		let mut adr = this -> ptr;
		adr += sizeof(uxx) + 4;
		return ptrv adr as u32;
	}

	func data() ptr %inline {
		let mut adr = this -> ptr;
		if(this.is_const()){
			adr += sizeof(uxx) + 1;
		} else {
			adr += sizeof(uxx) + 8;
		}
		return adr;
	}

	/////////////////////
	// Converts
	/////////////////////

	func to_lower() .String {
		let bytes = this.bytes();
		let data = this.data();
		let new_str = String.make_empty(bytes);
		let new_data = new_str.data();
		let mut pos : uxx = 0;
		while pos < bytes {
			let mut byte : u8 = ptrv (data + pos) as u8;
			if byte > 127 {
				let b2 = (byte & 32) > 0;
				let b3 = (byte & 16) > 0 && b2;
				let utf_chars : u8 = 2 + (b2 -> u8) + (b3 -> u8);
				let fits = ((pos + utf_chars) < bytes) -> u8;
				let utf_chars_safe = utf_chars * fits + (bytes - pos) * (fits == 0#u8) -> u8;
				mem:copy(data + pos, new_data + pos, utf_chars);
				pos += utf_chars;
				continue;
			}
			//
			let is_upper = (byte > 64 && byte < 91) -> u8;
			ptrv (new_data + pos) as u8 = byte + (is_upper * 32);
			pos++;
		}
		return new_str;
	}

	func cstring() cstring {
		let len = this.bytes();
		let bytes = len + 1;
		let adr = mem:alloc(bytes);
		mem:copy(this.data(), adr, len);
		ptrv (adr + len) as u8 = 0;
		return adr -> cstring;
	}

	/////////////////////
	// Internals
	/////////////////////

	func __ref() void {
		if this.is_const() { return; }
		let adr = (this -> ptr) + sizeof(uxx) + 4;
		let rc = atomicop ptrv adr as u32 ADD 1;
	}
	func __deref() void {
		if this.is_const() { return; }
		let adr = (this -> ptr) + sizeof(uxx) + 4;
		let rc = atomicop ptrv adr as u32 SUB 1;
		if rc == 1 {
			this.__free();
		}
	}
	func __free() void {
		if this.is_const() { return; }
		mem:free(this -> ptr);
	}

	func __add(str: String) String {
		let this_len = this.bytes();
		let str_len = str.bytes();
		let len = this_len + str_len;
		if len == 0 {
			return "";
		}
		let new_str = String.make_empty(len);
		let mut new_adr = new_str.data();
		mem:copy(this.data(), new_adr, this_len);
		new_adr += this_len;
		mem:copy(str.data(), new_adr, str_len);
		return new_str;
	}

	public func __eq(b: String) bool {
		let a_ptr = this -> ptr;
		let b_ptr = b -> ptr;
		if(a_ptr == b_ptr) {
			return true;
		}
		let bytes = this.bytes();
		if(bytes != b.bytes()){
			return false;
		}
		return mem:equal(this.data(), b.data(), bytes);
	}

	func __iter_init() uxx {
		return 0;
	}
	func __iter_get(key: uxx, next_key: uxx*) u8 !end {
		if key == this.bytes() {
			throw end;
		}
		ptrv next_key = key + 1;
		let data = this.data();
		return ptrv (data + key) as u8;
	}

	/////////////////////
	// Other
	/////////////////////

	static func make_empty(size: uxx) .String {
		let mut adr = mem:alloc(size + 8 + sizeof(uxx));
		let adr_ = adr;
		ptrv adr as uxx = size;
		adr += sizeof(uxx);
		ptrv adr as u8 = 0#u8;
		adr += 4;
		ptrv adr as u32 = 1#u32;
		let res = adr_ -> .String;
		return res;
	}

}
