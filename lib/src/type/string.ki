
// const:   {string_length:uxx}-1-{...string bytes...}
// dynamic: {string_length:uxx}-0-{pad 3}-{ref_count:u32}-{...string bytes...}

use mem;
use os;

class String type:ptr {

	/////////////////////
	// Core
	/////////////////////

	func is_const() bool %inline {
		return @ptrv(this -> ptr + sizeof(uxx), u8, 0) == 1#u8;
	}

	func bytes() uxx %inline {
		return @ptrv(this -> ptr, uxx, 0);
	}

	func rc() u32 %inline {
		if(this.is_const()) { return 666; } // Let the person who has insight calculate the number of the beast, for it is the number of a man. That number is 666.
		let mut adr = this -> ptr;
		adr += sizeof(uxx) + 4;
		return @ptrv(adr, u32, 0);
	}

	func data() ptr %inline {
		let mut adr = this -> ptr;
		if(this.is_const()){
			adr += sizeof(uxx) + 1;
		} else {
			adr += sizeof(uxx) + 8;
		}
		return adr;
	}

	/////////////////////
	// Read
	/////////////////////

	func byte(index: uxx) u8 %inline {
		return @ptrv(this.data(), u8, index);
	}

	func sub_str_bytes(start_index: uxx, mut length: uxx) String {
		let this_bytes = this.bytes();
		if(start_index > this_bytes){
			return "";
		}
		if((start_index + length) > this_bytes){
			length = this_bytes - start_index;
		}
		if(length == 0){
			return "";
		}
		let from = this.data() + start_index;
		let res = String.make_empty(length);
		mem:copy(from, res.data(), length);
		return res;
	}

	/////////////////////
	// Converts
	/////////////////////

	func to_lower() .String {
		let bytes = this.bytes();
		let data = this.data();
		let new_str = String.make_empty(bytes);
		let new_data = new_str.data();
		let mut pos : uxx = 0;
		while pos < bytes {
			let byte : u8 = @ptrv(data, u8, pos);
			if byte > 127 {
				@ptrv(new_data, u8, pos) = byte;
				pos++;
				continue;
			}
			let is_upper = (byte > 64 && byte < 91) -> u8;
			@ptrv(new_data, u8, pos) = byte + (is_upper * 32);
			pos++;
		}
		return new_str;
	}

	func cstring() cstring {
		let len = this.bytes();
		let bytes = len + 1;
		let adr = mem:alloc(bytes);
		mem:copy(this.data(), adr, len);
		@ptrv(adr + len, u8, 0) = 0;
		return adr -> cstring;
	}

	/////////////////////
	// Internals
	/////////////////////

	func __ref() void {
		if this.is_const() { return; }
		let adr = (this -> ptr) + sizeof(uxx) + 4;
		let rc = @ptrv(adr, u32, 0) + 1;
	}
	func __deref() void {
		if this.is_const() { return; }
		let adr = (this -> ptr) + sizeof(uxx) + 4;
		let rc = @ptrv(adr, u32, 0) - 1;
		if rc == 0 {
			this.__free();
		}
	}
	func __free() void {
		if this.is_const() { return; }
		mem:free(this -> ptr);
	}

	func __add(str: String) String {
		let this_len = this.bytes();
		let str_len = str.bytes();
		let len = this_len + str_len;
		if len == 0 {
			return "";
		}
		let new_str = String.make_empty(len);
		let mut new_adr = new_str.data();
		mem:copy(this.data(), new_adr, this_len);
		new_adr += this_len;
		mem:copy(str.data(), new_adr, str_len);
		return new_str;
	}

	public func __eq(b: String) bool {
		let a_ptr = this -> ptr;
		let b_ptr = b -> ptr;
		if(a_ptr == b_ptr) {
			return true;
		}
		let bytes = this.bytes();
		if(bytes != b.bytes()){
			return false;
		}
		return mem:equal(this.data(), b.data(), bytes);
	}

	func __iter_init() uxx {
		return 0;
	}
	func __iter_get(key: uxx, next_key: uxx[1]) u8 !end {
		if key == this.bytes() {
			throw end;
		}
		next_key[0] = key + 1;
		let data = this.data();
		return @ptrv(data + key, u8, 0);
	}

	/////////////////////
	// Other
	/////////////////////

	static func make_empty(size: uxx) .String {
		let mut adr = mem:alloc(size + 8 + sizeof(uxx));
		let adr_ = adr;
		@ptrv(adr, uxx, 0) = size;
		adr += sizeof(uxx);
		@ptrv(adr, u8, 0) = 0#u8;
		adr += 4;
		@ptrv(adr, u32, 0) = 1#u32;
		let res = adr_ -> >.String;
		return res;
	}

	static func format(baselen: uxx, parts: ptr, partc: uxx, values: ptr) .String {
		let mut bytes = baselen;
		let valuec = partc - 1;
		let mut i : uxx = 0;
		while i < valuec {
			let val = @ptrv(values, String, i);
			bytes += val.bytes();
			i++;
		}
		let result = String.make_empty(bytes);
		let mut data = result.data();
		i = 0;
		while i < partc {
			if i > 0 {
				let val = @ptrv(values, String, i - 1);
				let val_bytes = val.bytes();
				mem:copy(val.data(), data, val_bytes);
				data += val_bytes;
			}
			let part = @ptrv(parts, String, i);
			let part_bytes = part.bytes();
			mem:copy(part.data(), data, part_bytes);
			data += part_bytes;
			i++;
		}
		return result;
	}

}
