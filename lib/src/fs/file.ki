
header "ki_os" as kos;
header "sys" as sys;

use utils;
use mem;

func size(path: *String) uxx {
	let buf = @stack_alloc(@sizeof_class(sys.cstruct_stat)) @as sys.cstruct_stat;
	let res = stat(path, buf);
	if res == -1 {
		return 0;
	}
	return buf.st_size @as uxx;
}
func stat(path: *String, buf: *sys.cstruct_stat) ixx {
	let plen = path.bytes();
	let pdata = path.data();
	let cstr_ptr = @stack_alloc(plen + 1);
	mem:copy(pdata, cstr_ptr, plen);
	@ptrv(cstr_ptr, u8, plen) = '\0';
	let cstr = cstr_ptr @as cstring;
	return sys.stat(cstr, buf);
}

func read(path: *String) String !open !read !close {
	let fd = kos.ki_os__file_open(path.data(), path.bytes() @as i32, true, false);
	if fd == -1 {
		throw open;
	}
	let len : uxx = 0;

	let res = utils:ByteBuffer.init(4096);
	let buf = @stack_alloc(4096);
	let readcount_ : ixx = 4096;
	while true {
		let readcount = kos.ki_os__fd_read(fd, buf, 4096);
		if(readcount < 0){
			throw read;
		}
		res.append_from_ptr(buf, readcount @as uxx);
		if(readcount != readcount_) {
			break;
		}
	}

	let check = kos.ki_os__fd_close(fd);
	if(check != 0){
		//throw close;
	}

	return res.to_str();
}

func exists(path: *String) bool {
	let fd = kos.ki_os__file_open(path.data(), path.bytes() @as i32, true, false);
	if(fd == -1) {
		return false;
	}
	let check = kos.ki_os__fd_close(fd);
	return true;
}
func delete(path: *String) void !failed {
	if !kos.ki_os__file_delete(path.data(), path.bytes() @as i32) {
		throw failed;
	}
}
func mkdir(path: *String) void !failed {
	if !kos.ki_os__file_mkdir(path.data(), path.bytes() @as i32) {
		throw failed;
	}
}
