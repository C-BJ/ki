
header "ki_os" as kos;

use utils;

func size(path: *String) uxx {
	let buf = @stack_alloc(@sizeof_class(kos.ki_file_stats)) @as kos.ki_file_stats;
	let stat = kos.ki_os__file_stats(path.data(), path.bytes() @as i32, buf);
	rep stat = stat ?! return 0;;
	return stat.size;
}

func read(path: *String) String !open !read !close {
	let fd = kos.ki_os__file_open(path.data(), path.bytes() @as i32, true, false);
	if fd == -1 {
		throw open;
	}
	let len : uxx = 0;

	let res = utils:ByteBuffer.init(4096);
	let buf = @stack_alloc(4096);
	let readcount_ : ixx = 4096;
	while true {
		let readcount = kos.ki_os__fd_read(fd, buf, 4096);
		if(readcount < 0){
			throw read;
		}
		res.append_from_ptr(buf, readcount @as uxx);
		if(readcount != readcount_) {
			break;
		}
	}

	let check = kos.ki_os__fd_close(fd);
	if(check != 0){
		//throw close;
	}

	return res.to_str();
}

func exists(path: *String) bool {
	let fd = kos.ki_os__file_open(path.data(), path.bytes() @as i32, true, false);
	if(fd == -1) {
		return false;
	}
	let check = kos.ki_os__fd_close(fd);
	return true;
}
func delete(path: *String) void !failed {
	if !kos.ki_os__file_delete(path.data(), path.bytes() @as i32) {
		throw failed;
	}
}
func mkdir(path: *String) void !failed {
	if !kos.ki_os__file_mkdir(path.data(), path.bytes() @as i32) {
		throw failed;
	}
}
