
header "ki_os" as kos;

use mem;

global EXE_PATH : ?String;
global EXE_DIR : ?String;

class Path {
	parts: Array[String];

	static func init(path: String) Path {
		return Path{
			parts: path.split("/"),
		};
	}

	static func exe_dir() Path {
		let path = Path.exe_path();
		path.pop();
		return path;
	}
	static func exe_path() Path {
		return Path.init(exe_dir());
	}

	func copy() Path {
		let parts = this.parts;
		let new = Array[String].init();
		each parts as part {
			new.push(part);
		}
		return Path{
			parts: new,
		};
	}

	func pop() void {
		let parts = this.parts;
		if parts.length > 1 {
			parts.pop();
		}
	}

	//func to_str() String {
	//	return this.parts.join("/");
	//}
}

func exe_dir() &String {
	let res = EXE_DIR ?! {
		let dir = dir_of(exe_path());
		EXE_DIR = dir;
		return exe_dir();
	};
	return res;
}
func exe_path() &String {
	let cstr = kos.ki_os__exe_path();
	let res = EXE_PATH ?! {
		let dir = +cstr.to_str();
		EXE_PATH = dir;
		return dir;
	};
	return res;
}

func ext(path: String) String {
	let len = path.bytes();
	let start = len;
	let found = false;
	while start > 0 {
		start--;
		let ch = path.byte(start);
		if ch == '.' {
			start++;
			found = true;
			break;
		}
		if ch == '/' || ch == '\\' {
			break;
		}
	}
	if found == false {
		return "";
	}
	return path.sub_str_bytes(start, len - start);
}

// e.g. /etc/nginx/nginx.conf -> /etc/nginx
// e.g. /etc/nginx/ -> /etc
// e.g. /etc -> /
// e.g. "" -> ""
// e.g. etc -> etc
func dir_of(path: String) String {
	let end = path.bytes() - 1;
	while(end > 0){
		end--;
		let ch = path.byte(end);
		if(ch == '/' || ch == '\\'){
			if end == 0 {
				end++;
			}
			return path.sub_str_bytes(0, end);
		}
	}
	return path + "";
}

// e.g. /etc/nginx/nginx.conf -> nginx.conf
// e.g. /etc/nginx/ -> nginx
// e.g. / -> ""
// e.g. "" -> ""
func basename(path: String) String {
	let len = path.bytes();
	let start = len;
	while(start > 0){
		start--;
		let ch = path.byte(start);
		if(ch == '/' || ch == '\\'){
			start++;
			break;
		}
	}
	return path.sub_str_bytes(start, len - start);
}

global g_stat_buf : ?kos.ki_file_stats;
func get_stat_buf() &kos.ki_file_stats {
	let s = g_stat_buf ?! {
		let s = mem:alloc(sizeof_class(kos.ki_file_stats)) @as >.kos.ki_file_stats;
		g_stat_buf = s;
		return get_stat_buf();
	};
	return s;
}

func is_file(path: String) bool {
	let buf = get_stat_buf();
	let stat = kos.ki_os__file_stats(path.data(), path.bytes() @as i32, buf);
	rep stat = stat ?! return false;;
	return stat.is_file;
}
func is_dir(path: String) bool {
	let buf = get_stat_buf();
	let stat = kos.ki_os__file_stats(path.data(), path.bytes() @as i32, buf);
	rep stat = stat ?! return false;;
	return stat.is_file == false;
}
