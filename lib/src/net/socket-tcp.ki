
header "sys" as sys;

use mem;

class SocketTCP async {
	readonly fd: i32;
	port: u16;

	static func init(host: *String, port: u16) SocketTCP !os_socket_create !get_addr_info !bind !listen {

    	let fd = sys.socket(sys.OS.AF_INET, sys.OS.SOCK_STREAM | sys.OS.SOCK_NONBLOCK, 0);
    	if fd == -1 {
			throw os_socket_create;
    	}

		let yes : i32 = 1;
		let yes_ptr = @var_ptr(yes);
    	sys.setsockopt(fd, sys.OS.SOL_SOCKET, sys.OS.SO_REUSEADDR, yes_ptr, @sizeof(i32));
    	sys.setsockopt(fd, sys.OS.SOL_SOCKET, sys.OS.SO_REUSEPORT, yes_ptr, @sizeof(i32));
		
		let addrinfo : ?sys.cstruct_addrinfo = null;
		let hints = @stack_object(sys.cstruct_addrinfo);
		mem:clear(hints @as ptr, @sizeof_class(sys.cstruct_addrinfo));
		hints.ai_family = sys.OS.AF_INET;
		hints.ai_socktype = sys.OS.SOCK_STREAM;
		hints.ai_flags = sys.OS.AI_PASSIVE;

		let chost = host.to_cstring();
		let cport = port.str().to_cstring();
    	let err = sys.getaddrinfo(chost, cport, hints, @var_array(addrinfo));
		if err != 0 {
			throw get_addr_info;
		}
		rep addrinfo = addrinfo ?! {
			throw get_addr_info;
		};

    	err = sys.bind(fd, addrinfo.ai_addr, addrinfo.ai_addrlen);
		if err != 0 {
			throw bind;
		}

    	err = sys.listen(fd, 2000000);
		if err != 0 {
			throw listen;
		}

		sys.freeaddrinfo(addrinfo);

		return SocketTCP{
			port: port,
			fd: fd,
		};
	}

	func accept() Connection !error {
		let fd = sys.accept(this.fd, null, null);
		if fd == -1 {
			throw error;
		}
		return Connection {
			fd: fd,
		};
	}

	func clone() CLASS {
		return CLASS {
			fd: this.fd,
			port: this.port,
		};
	}
}