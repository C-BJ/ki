
class Allocator norc {
	first: Block;
	current: Block;
	block_count: uxx;
	total_slots: uxx;
	total_slots_used: uxx;
	slot_size: uxx;
	slot_size_real: uxx;
	misalign_bytes: u8;

	static func init(slot_size: uxx, misalign_bytes: u8 = 0) Allocator {

		// Calculate size
		let real_size = slot_size + 1;
		// 8 - 9 % 8 = 7 
		let mod = slot_size;
		if mod > 8 { mod = 8; }
		real_size += mod - real_size % mod;

		let count = 4#u16;
		let alc = sys_alloc(sizeof(Allocator)) @as mut Allocator;
		let block = Block.create(alc, real_size, count @as u8, misalign_bytes);
		alc.first = block;
		alc.current = block;
		alc.block_count = 1;
		alc.slot_size = slot_size;
		alc.slot_size_real = real_size;
		alc.total_slots = count;
		alc.total_slots_used = 0;
		alc.misalign_bytes = misalign_bytes;

		return alc;
	}

	func mut get_slot() ptr {
		this.total_slots_used += 1;
		let b = this.current;
		while true {
			if b.is_empty() && false {
				// Decide wether to free the block or not
				if (this.total_slots / this.total_slots_used) > 2 {
					this.total_slots -= b.slot_count;
					let next = b.next;
					b.free();
					b = next ?? this.first;
					continue;
				}
			}
			if b.has_free_slots {
				this.current = b;
				return b.get_slot();
			}
			let next = b.next;
			b = next ?! break;;
		}
		// No open slots
		// Decide to create new block or use previous blocks
		if this.block_count < 10 || (this.total_slots / this.total_slots_used) < 2 {
			// Create new block
			let pow = this.block_count;
			if pow > 10 {
				pow = 10;
			}
			let count = 4 << pow;
			if count > 240 {
				count = 240;
			}
			let nb = Block.create(this, this.slot_size_real, count @as u8, this.misalign_bytes);
			b.next = nb;
			nb.prev = b;
			this.current = nb;
			this.block_count += 1;
			this.total_slots += count;
			return nb.get_slot();
		}
		// Use previous blocks
		this.current = this.first;
		this.total_slots_used -= 1;
		return this.get_slot();
	}

	func mut free(adr: ptr) void {
		adr -= 1;
		let slot_nr = @ptrv(adr, u8, 0);
		adr -= (slot_nr * this.slot_size_real);

		adr -= 1;
		let align_bytes = @ptrv(adr, u8, 0);
		adr -= align_bytes + 1;
		let slot_count = @ptrv(adr, u8, 0);
		//println((slot_count @as u32).str());
		adr -= slot_count + sizeof(ptr);

		let b = @ptrv(adr, Block, 0);
		b.free_slot(slot_nr);

		// Make atomic
		// let used = atomicop this.total_slots_used SUB 1;
		this.total_slots_used -= 1;
	}

}
