

// { ptr : block adr } { u8[slot_count] : slot nrs } { u8 : slot_count } { u8[align_bytes] } { u8 : align_bytes } | slot_count * { slot_size }

class Block norc {
	alc: Allocator;
	prev: ?Block = null;
	next: ?Block = null;
	data: ptr;
	data_slot_nrs: ptr;
	data_slots: ptr;
	slot_size: uxx;
	slot_count: u8;
	head: u8;
	tail: u8;
	align_bytes: u8;
	misalign_bytes: u8;
	has_free_slots: bool;

	static func create(alc: Allocator, slot_size: uxx, slot_count: u8, misalign_bytes: u8) Block {

		misalign_bytes += 1; // Slot byte
		misalign_bytes = misalign_bytes % 8;

		let b = sys_alloc(sizeof(Block)) @as mut Block;
		b.alc = alc;
		b.prev = null;
		b.next = null;
		b.slot_count = slot_count;
		b.slot_size = slot_size;
		b.head = 0;
		b.tail = 0;
		b.misalign_bytes = misalign_bytes;
		b.has_free_slots = true;

		// Alignment
		let tmp = 0#i32 + slot_count + 2;
		tmp = 8 - tmp % 8;
		tmp -= misalign_bytes;
		if tmp < 0 { tmp += 8; }
		let align_bytes = tmp @as u8;

		// Setup data
		let size : uxx = sizeof(ptr) + 2 + slot_count + align_bytes + (slot_count * slot_size);
		let data = sys_alloc(size);
		b.data = data;

		let adr = data;
		@ptrv(adr, ptr, 0) = b @as ptr;
		adr += sizeof(ptr);

		b.data_slot_nrs = adr;

		// Setup slot positions
		let i = 0#u8;
		while i < slot_count {
			@ptrv(adr, u8, 0) = i;
			adr += 1;
			i += 1;
		}
		@ptrv(adr, u8, 0) = slot_count;
		adr += 1;

		//
		b.align_bytes = align_bytes;
		adr += align_bytes;
		@ptrv(adr, u8, 0) = align_bytes;
		adr += 1;

		b.data_slots = adr;

		i = 0;
		while i < slot_count {
			@ptrv(adr, u8, 0) = i;
			adr += slot_size;
			i += 1;
		}

		return b;
	}

	func is_empty() bool {
		return this.tail == this.head && this.has_free_slots;
	}

	func mut get_slot() ptr {
		let head = this.head;

		let slot_nr_adr = this.data_slot_nrs + head;
		let slot_nr = @ptrv(slot_nr_adr, u8, 0);

		let slot_adr = this.data_slots + (slot_nr * this.slot_size);

		let next_head = head + 1;
		if next_head == this.slot_count {
			next_head = 0;
		}
		this.head = next_head;

		if next_head == this.tail {
			this.has_free_slots = false;
		}

		return slot_adr + 1;
	}

	func mut free_slot(slot_nr: u8) void {

		let slot_count = this.slot_count;

		// Make atomic
		let tail = this.tail;
		// let tail = atomicop this.tail ADD 1;
		// if tail == slot_count {
		//     let reduce = atomicop this.tail SUB slot_count;
		// } else if (tail > slot_count) {
		//     tail -= slot_count;
		// }

		let slot_nr_adr = this.data_slot_nrs + tail;
		@ptrv(slot_nr_adr, u8, 0) = slot_nr;

		// Remove when atomic
		let next_tail = tail + 1;
		if next_tail == slot_count {
			next_tail = 0;
		}
		this.tail = next_tail;

		this.has_free_slots = true;
	}

	func free() void {
		sys_free(this.data);
	}
}