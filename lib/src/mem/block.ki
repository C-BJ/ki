

// { ptr : block adr } { u8[slot_count] : slot nrs } { u8 : slot_count } { u8[align_bytes] } { u8 : align_bytes } | slot_count * { slot_size }

class Block norc {
	alc: Allocator;
	prev: ?Block = null;
	next: ?Block = null;
	data: ptr;
	data_slot_nrs: ptr;
	data_slots: ptr;
	slot_size: uxx;
	slot_count: u8;
	head: u8;
	tail: u8;
	align_bytes: u8;
	misalign_bytes: u8;

	static func create(Allocator alc, uxx slot_size, u8 slot_count, u8 mut misalign_bytes) Block {

		misalign_bytes += 1; // Slot byte
		misalign_bytes = misalign_bytes % 8;

		let b = sys_alloc(sizeof(Block)) -> Block;
		b.alc = alc;
		b.prev = null;
		b.next = null;
		b.slot_count = slot_count;
		b.slot_size = slot_size;
		b.head = 0;
		b.tail = 0;
		b.misalign_bytes = misalign_bytes;

		// Alignment
		let mut tmp = 0#i32 + slot_count + 2;
		tmp = 8 - tmp % 8;
		tmp -= misalign_bytes;
		if tmp < 0 { tmp += 8; }
		let align_bytes = tmp -> u8;

		// Setup data
		let size : uxx = sizeof(ptr) + 2 + slot_count + align_bytes + (slot_count * slot_size);
		let data = sys_alloc(size);
		b.data = data;

		let mut adr = data;
		ptrv adr as ptr = b -> ptr;
		adr += sizeof(ptr);

		b.data_slot_nrs = adr;

		// Setup slot positions
		let mut i = 0#u8;
		while i < slot_count {
			ptrv adr as u8 = i;
			adr += 1;
			i += 1;
		}
		ptrv adr as ptr = slot_count;
		adr += 1;

		//
		b.align_bytes = align_bytes;
		adr += align_bytes;
		ptrv adr as ptr = align_bytes;
		adr += 1;

		b.data_slots = adr;

		i = 0;
		while i < slot_count {
			ptrv adr as u8 = i;
			adr += slot_size;
			i += 1;
		}

		return b;
	}

	func has_open_slot() bool {
		let mut next_head = this.head + 1;
		if next_head == this.slot_count {
			next_head = 0;
		}
		return next_head != this.tail;
	}

	func get_slot() ptr {
		let mut next_head = this.head + 1;
		if next_head == this.slot_count {
			next_head = 0;
		}
		let head = next_head;
		this.head = head;

		let slot_nr_adr = this.data_slot_nrs + sizeof(ptr) + head;
		let slot_nr = ptrv slot_nr_adr as u8;

		let slot_adr = this.data_slots + (slot_nr * this.slot_size);

		return slot_adr + 1;
	}

	func is_empty() bool {
		return this.tail == this.head;
	}

	func free_slot(u8 slot_nr) void {

		let slot_count = this.slot_count;

		// Make atomic
		let tail = this.tail;
		// let tail = atomicop this.tail ADD 1;
		// if tail == slot_count {
		//     let reduce = atomicop this.tail SUB slot_count;
		// } else if (tail > slot_count) {
		//     tail -= slot_count;
		// }

		let slot_nr_adr = this.data_slot_nrs + tail;
		ptrv slot_nr_adr as u8 = slot_nr;

		// Remove when atomic
		let mut next_tail = tail + 1;
		if next_tail == slot_count {
			next_tail = 0;
		}
		this.tail = next_tail;
	}

	func free() void {
		sys_free(this.data);
	}
}