
header "ki_os" as os;

global allocators : ?ptr;

#if 1
func alloc(uxx size) ptr {
	return os.ki_os__alloc(size);
}
func free(ptr adr) void {
	os.ki_os__free(adr);
}
#else
func alloc(uxx size) ptr {
	let mut alcs = allocators;
	if alcs == null {
		let size : uxx = 64#uxx * sizeof(ptr);
		let list = sys_alloc(size);
		clear(list, size);
		allocators = list;
		alcs = list;
	}

	let mut pow = 4#u8;
	let mut cmp = 16#uxx;
	while cmp < size {
		cmp = cmp << 1;
		pow += 1;
	}

	let adr : ptr = (alcs -> ptr) + (pow * sizeof(ptr));
	let mut alc = ptrv adr as ?Allocator;
	if alc == null {
		alc = Allocator.init(1#uxx << pow + 1, 1);
		ptrv adr as ?Allocator = alc;
	}
	// Get chunk
	rep alc = alc -> Allocator;
	let res = alc.get_slot();
	ptrv res as u8 = pow;

	return res + 1;
}
func free(ptr mut adr) void {
	let alcs = allocators -> ptr;
	adr-=1;
	let pow : u32 = ptrv adr as u8;
	let alc_adr = alcs + (pow * sizeof(ptr));
	let mut alc = ptrv alc_adr as Allocator;
	alc.free(adr);
	return;
}
#end

func sys_alloc(uxx size) ptr {
	return os.ki_os__alloc(size);
}
func sys_free(ptr adr) void {
	os.ki_os__free(adr);
}

func clear(ptr mut adrc, uxx mut size) void {
	while(size > sizeof(ptr)){
		ptrv adrc as uxx = 0#uxx;
		adrc += sizeof(ptr);
		size -= sizeof(ptr);
	}
	while(size > 3){
		ptrv adrc as u32 = 0#u32;
		adrc += 4;
		size -= 4;
	}
	while(size > 1){
		ptrv adrc as u16 = 0#u16;
		adrc += 2;
		size -= 2;
	}
	while(size > 0){
		ptrv adrc as u8 = 0#u8;
		adrc+=1;
		size-=1;
	}
}

func copy(ptr mut from, ptr mut to, uxx mut len) void {

  while(len > sizeof(ptr)){
	  len -= sizeof(ptr);
	  ptrv to as uxx = ptrv from as uxx;
	  from += sizeof(ptr);
	  to += sizeof(ptr);
  }
  while(len > 3){
	  len -= 4;
	  ptrv to as u32 = ptrv from as u32;
	  from += 4;
	  to += 4;
  }
  while(len > 1){
	  len -= 2;
	  ptrv to as u16 = ptrv from as u16;
	  from += 2;
	  to += 2;
  }
  while (len > 0){
	  len-=1;
	  ptrv to as u8 = ptrv from as u8;
	  from+=1;
	  to+=1;
  }
}
